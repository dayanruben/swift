// RUN: %target-sil-opt %s \
// RUN:   --lifetime-dependence-diagnostics \
// RUN:   -verify \
// RUN:   -sil-verify-all \
// RUN:   -module-name Swift \
// RUN:   -enable-experimental-feature LifetimeDependence \
// RUN:   -o /dev/null

// REQUIRES: swift_in_compiler
// REQUIRES: swift_feature_LifetimeDependence

// Verify diagnostics from the LifetimeDependenceDiagnostics pass.

sil_stage raw

import Builtin

@_marker protocol Copyable: ~Escapable {}
@_marker protocol Escapable: ~Copyable {}

class C {}

struct NE : ~Escapable {}

struct NEObject : ~Escapable {
  var c: C

  @lifetime(immortal)
  init()
}

public struct Holder {
  var c: C
}

struct A {}

struct NCWrapper : ~Copyable, ~Escapable {
  @_hasStorage let a: NE { get }
  deinit
}

sil @getNEPointer : $@convention(thin) (@guaranteed NE) -> Builtin.RawPointer
sil @useA : $@convention(thin) (A) -> ()
sil @makeNE : $@convention(thin) () -> @lifetime(immortal) @owned NE
sil @makeNEObject : $@convention(thin) () -> @lifetime(immortal) @owned NEObject
sil @useNE : $@convention(thin) (NE) -> ()

// Test returning a owned dependence on a trivial value
sil [ossa] @return_trivial_dependence : $@convention(thin) (@guaranteed C) -> @lifetime(borrow 0) @owned NE {
entry(%0 : @guaranteed $C):
  %zero = integer_literal $Builtin.Int1, 0
  %makeNE = function_ref @makeNE : $@convention(thin) () -> @lifetime(immortal) @owned NE
  %call = apply %makeNE() : $@convention(thin) () -> @lifetime(immortal) @owned NE
  // expected-error @-1{{lifetime-dependent value escapes its scope}}
  // expected-note  @-4{{it depends on the lifetime of this parent value}}
  %mark = mark_dependence [unresolved] %call : $NE on %zero : $Builtin.Int1
  return %mark // expected-note {{this use causes the lifetime-dependent value to escape}}
}

// Test returning a unowned dependence on a trivial value
sil [ossa] @return_object_trivial_dependence : $@convention(thin) (@guaranteed C) -> @lifetime(borrow 0) @owned NEObject {
entry(%0 : @guaranteed $C):
  %zero = integer_literal $Builtin.Int1, 0
  %makeNE = function_ref @makeNEObject : $@convention(thin) () -> @lifetime(immortal) @owned NEObject
  %call = apply %makeNE() : $@convention(thin) () -> @lifetime(immortal) @owned NEObject
  // expected-error @-1{{lifetime-dependent value escapes its scope}}
  // expected-note  @-4{{it depends on the lifetime of this parent value}}
  %mark = mark_dependence [unresolved] %call : $NEObject on %zero : $Builtin.Int1
  return %mark // expected-note {{this use causes the lifetime-dependent value to escape}}
}

// OK: Test that the range initialized by a store_borrow covers dependent uses.
sil [ossa] @testStoreBorrowRange : $@convention(thin) (@owned Holder) -> () {
bb0(%0 : @owned $Holder):
  %val = move_value [lexical] [var_decl] %0
  %stk = alloc_stack $Holder
  %sb = store_borrow %val to %stk
  %f1 = function_ref @makeNE : $@convention(thin) () -> @lifetime(immortal) @owned NE
  %c1 = apply %f1() : $@convention(thin) () -> @lifetime(immortal) @owned NE
  %md = mark_dependence [unresolved] %c1 on %sb
  %mv = move_value [var_decl] %md
  %f2 = function_ref @useNE : $@convention(thin) (NE) -> ()
  %c2 = apply %f2(%mv) : $@convention(thin) (NE) -> ()
  destroy_value %mv
  end_borrow %sb
  dealloc_stack %stk
  destroy_value %val
  %99 = tuple ()
  return %99
}

// Test that local variable analysis can handle an address-type mark_dependence on an address base. The drop_deinit
// also creates an an unknown address scope, preventing diagnostics from promoting the mark_dependence to noescape.
sil [ossa] @testMarkDepAddressProjection : $@convention(thin) (@owned NCWrapper) -> () {
bb0(%0 : @owned $NCWrapper):
  %1 = alloc_stack $NCWrapper, let, name "self", argno 1
  store %0 to [init] %1
  %3 = drop_deinit %1
  %4 = struct_element_addr %3, #NCWrapper.a
  %5 = load_borrow %4

  %6 = function_ref @getNEPointer : $@convention(thin) (@guaranteed NE) -> Builtin.RawPointer
  %7 = apply %6(%5) : $@convention(thin) (@guaranteed NE) -> Builtin.RawPointer
  %8 = pointer_to_address %7 to [strict] $*A
  %9 = mark_dependence [unresolved] %8 on %4
  %10 = begin_access [read] [unsafe] %9
  %11 = load [trivial] %10
  end_access %10

  %13 = function_ref @useA : $@convention(thin) (A) -> ()
  %14 = apply %13(%11) : $@convention(thin) (A) -> ()
  end_borrow %5
  dealloc_stack %1
  %17 = tuple ()
  return %17
}
